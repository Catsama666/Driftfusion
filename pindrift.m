function solstruct = pindrift(varargin);

%%
%%%%%%% REQUIREMENTS %%%%%%%%%%%%
% Requires v2struct toolbox for unpacking parameters structure
% IMPORTANT! Currently uses parameters from pinParams
% ALL VARIABLES MUST BE DECLARED BEFORE UNPACKING STRUCTURE (see below)
% spatial mesh is generated by meshgen_x
% time mesh is generated by meshgen_t

%%%%%%% GENERAL NOTES %%%%%%%%%%%%
% A routine for solving the diffusion and drift equations using the
% matlab pdepe solver. 
% 
% The solution from the solver is a 3D matrix, u:
% rows = time
% columns = space
% u(1), layer 1 = electron density, n
% u(2), layer 2 = hole density, p
% u(3), layer 3 = mobile defect density, a
% u(4), layer 4 = electric potential, V
%
% The solution structure solstruct contains the solution in addition to
% other useful outputs including the parameters sturcture

%%%%% INPUTS ARGUMENTS %%%%%%%
% This version allows a previous solution to be used as the input
% conditions. If there is no input argument asssume default flat background
% condtions. If there is one argument, assume it is the previous solution
% to be used as the initial conditions (IC). If there are two input arguments,
% assume that first is the previous solution, and the
% second is a parameters structure. If the IC sol = 0, default intial conditions
% are used, but parameters can still be input. If the second argument is
% any character e.g. 'params', then the parameters from the input solution
% i.e. the first argument are used.
%  
% AUTHORS
% Piers Barnes last modified (09/01/2016)
% Phil Calado last modified (14/07/2017)
% Mohammed Azzousi
% Benjamin Hilton
% Ilario Gelmetti

%% Graph formatting
set(0,'DefaultLineLinewidth',1);
set(0,'DefaultAxesFontSize',16);
set(0,'DefaultFigurePosition', [600, 400, 450, 300]);
set(0,'DefaultAxesXcolor', [0, 0, 0]);
set(0,'DefaultAxesYcolor', [0, 0, 0]);
set(0,'DefaultAxesZcolor', [0, 0, 0]);
set(0,'DefaultTextColor', [0, 0, 0]);

%% Input arguments are dealt with here
if isempty(varargin)

    params = pinParams;      % Calls Function pinParams and stores in sturcture 'params'

elseif length(varargin) == 1
    
    % Call input parameters function
    icsol = varargin{1, 1}.sol;
    icx = varargin{1, 1}.x;
    params = pinParams;

elseif length(varargin) == 2 

    if max(max(max(varargin{1, 1}.sol))) == 0

       params = varargin{2};
    
    elseif isa(varargin{2}, 'char') == 1            % Checks to see if argument is a character
        
        params = varargin{1, 1}.params;
        icsol = varargin{1, 1}.sol;
        icx = varargin{1, 1}.x;
    
    else
    
        icsol = varargin{1, 1}.sol;
        icx = varargin{1, 1}.x;
        params = varargin{2};
    
    end

end

%% Declaration of Variables
% The scoping rules for nested and anonymous functions require that all variables
% used within the function be present in the text of the code.
% Rememeber to add new variables here if adding to parameters list- might
% be a better way of doing this.

[Ana, BL,BC, Bn ,calcJ, deltax, e, EA,Eg,Ei,Etetl, Ethtl, IP,IC,ilt, Int, JV, JVscan_pnts, N0,NA,ND,NI,PhiA,...
    PhiC,T,Tn,Vapp,Vbi,cn,cp, deltat, edge, Eti, Efnside, Efpside,ep,epoints,epp0,eppp,eppi,eppn,...
    et,etln0,etlp0,fastrec,figson,G0, htln0,htlp0, kB,kext, klin, klincon, krad,kradetl, kradhtl,m,meshx_figon, mesht_figon, mobset,...
    mobseti, mue_p,muh_p, mue_i, muh_i, mue_n, muh_n, mui, ni, nti, ntetl, nthtl,OC, OM, pepe, pedge,...
    pii, pint, pinter, pn, pp, pscr, ptetl, pthtl, pti, pulseint, pulselen, pulseon, pulsestart, q, JVscan_rate, se,sn, sp, side, etlsn, etlsp,...
    htlsn, htlsp, taun_i, taup_i, taun_etl, taun_htl, taup_etl, taup_htl, te, ti, tint, tinter, tp, tn, t0,taun,...
    taup,tmax, tmesh_type,tpoints, tscr, Vend, Vstart, v, varlist, varstr, wn, wp, wscr, x0,xmax,xmesh_type,...
    xpoints] = deal(0);

%% Unpack params structure for use in current workspace 
v2struct(params);

% Currently have to repack params since values change after unpacking- unsure as to what's happening there
% Pack parameters in to structure 'params'
varcell = who('*')';                    % Store variables names in cell array
varcell = ['fieldnames', varcell];      % adhere to syntax for v2struct

params = v2struct(varcell);

%% Spatial mesh
if length(varargin) == 0 || length(varargin) == 2 && max(max(max(varargin{1, 1}.sol))) == 0
    
    % Edit meshes in mesh gen
    x = meshgen_x(params);
    
        if OC == 1
        
        % Mirror the mesh for symmetric model - symmetry point is an additional
        % point at device length + 1e-7
        x1 = x;
        x2 = xmax - fliplr(x) + x(end);
        x2 = x2(2:end);                 % Delete initial point to ensure symmetry
        x = [x1, x2];
        
        end
        
    icx = x;
    
else
          
        x = icx;

end

xpoints = length(x);
xmax = x(end);     

%% Time mesh
t = meshgen_t(params);

%% Call solver

% SOLVER OPTIONS  - limit maximum time step size during integration.
options = odeset('MaxOrder',5, 'NonNegative', [1, 1, 1, 0]);%, 'RelTol', 1e-7);     % Reduce RelTol to improve accuracy of solution

% inputs with '@' are function handles to the subfunctions
% below for the: equation, initial conditions, boundary conditions
sol = pdepe(m,@pdex4pde,@pdex4ic,@pdex4bc,x,t,options);

%% Set up partial differential equation (pdepe) (see MATLAB pdepe help for details of c, f, and s)
function [c,f,s,iterations] = pdex4pde(x,t,u,DuDx)

% Open circuit condition- symmetric model
if (OC ==1)
    
    if x > xmax/2

        x = xmax - x;

    end
    
end

%% Generation     

% Beer Lambert or Transfer Matrix 1 Sun - NOT CURRENTLY IMPLEMENTED!
if Int ~= 0 && OM ==1 || Int ~= 0 && OM == 2
     
      if x > tp && x < (tp+ti) 
          g = Int*interp1(genspace, Gx1S, (x-tp));
      else
          g = 0;
      end
 
    % Add pulse
    if pulseon == 1
        if  t >= 10e-6 && t < pulselen + 10e-6
           if x > tp && x < (tp+ti)
                lasg = pulseint*interp1(genspace, GxLas, (x-tp));
                g = g + lasg;
           end
        end
    end
  
% Uniform Generation
elseif OM == 0
      
      if Int ~= 0 && x > tp && x < (tp+ti)    
           g = Int*G0;
      else
           g = 0;
      end
        
        % Add pulse
        if pulseon == 1
            if  t >= pulsestart && t < pulselen + pulsestart
                
                g = g+(pulseint*G0);
            
            end
        end
        
else
        g = 0;    
end

%% Transport and continuity equations
% Prefactors set to 1 for time dependent components - can add other
% functions if you want to include the multiple trapping model
% f indicates flux terms
% s indicates source terms - see pdepe help for how these are implemented - be careful of signs! 

c = [1      % electron density
     1      % hole density
     1      % mobile ion density
     0];    % electric potential

% p-type
if x >= 0 && x <= tp - tscr

 f = [(mue_p*(u(1)*-DuDx(4)+kB*T*DuDx(1)));
     (muh_p*(u(2)*DuDx(4)+kB*T*DuDx(2)));     
     0;                                         % Ion mobility is switched off in the contact regions
     DuDx(4);];                                  
 
 % source terms - for electrons and hole the first term is radiative rec,
 % second term is SRH recombination
 s = [ - kradhtl*((u(1)*u(2))-(ni^2)) - (((u(1)*u(2))-ni^2)/((taun_htl*(u(2)+pthtl)) + (taup_htl*(u(1)+nthtl))));
       - kradhtl*((u(1)*u(2))-(ni^2)) - (((u(1)*u(2))-ni^2)/((taun_htl*(u(2)+pthtl)) + (taup_htl*(u(1)+nthtl))));
      0;
      (q/eppp)*(-u(1)+u(2)-NA+u(3)-NI);];
  
elseif x > tp - tscr && x <= tp
    
 f = [(mue_p*(u(1)*-DuDx(4)+kB*T*DuDx(1)));
     (muh_p*(u(2)*DuDx(4)+kB*T*DuDx(2)));     
     0;
     DuDx(4);];                                  

 s = [ - kradhtl*((u(1)*u(2))-(ni^2)) - (((u(1)*u(2))-ni^2)/((taun_htl*(u(2)+pthtl)) + (taup_htl*(u(1)+nthtl)))); %- klincon*min((u(1)- htln0), (u(2)- htlp0)); % 
       - kradhtl*((u(1)*u(2))-(ni^2)) - (((u(1)*u(2))-ni^2)/((taun_htl*(u(2)+pthtl)) + (taup_htl*(u(1)+nthtl)))); %- kradhtl*((u(1)*u(2))-(ni^2)); %- klincon*min((u(1)- htln0), (u(2)- htlp0)); % - (((u(1)*u(2))-ni^2)/((taun_htl*(u(2)+pthtl)) + (taup_htl*(u(1)+nthtl))));
      0;
      (q/eppp)*(-u(1)+u(2)+u(3)-NI-NA);];
 
% Intrinsic
elseif x > tp && x < tp + ti
    
   f = [(mue_i*(u(1)*-DuDx(4)+kB*T*DuDx(1)));
     (muh_i*(u(2)*DuDx(4)+kB*T*DuDx(2))); 
     (mui*(u(3)*DuDx(4)+kB*T*DuDx(3))); 
     DuDx(4);];                                     

 s = [g - krad*((u(1)*u(2))-(ni^2)) - (((u(1)*u(2))-ni^2)/((taun_i*(u(2)+pti)) + (taup_i*(u(1)+nti)))); 
      g - krad*((u(1)*u(2))-(ni^2)) - (((u(1)*u(2))-ni^2)/((taun_i*(u(2)+pti)) + (taup_i*(u(1)+nti))));
      0;
      (q/eppi)*(-u(1)+u(2)+u(3)-NI);]; 

% n-type
elseif x >= tp + ti && x < tp + ti + tscr
  
 f = [(mue_n*(u(1)*-DuDx(4)+kB*T*DuDx(1)));
     (muh_n*(u(2)*DuDx(4)+kB*T*DuDx(2)));      
     0;
     DuDx(4)];                                      

s = [ - kradetl*((u(1)*u(2))-(ni^2)) - (((u(1)*u(2))-ni^2)/((taun_etl*(u(2)+ptetl)) + (taup_etl*(u(1)+ntetl))));   %- kradetl*((u(1)*u(2))-(ni^2)); %- klincon*min((u(1)- etln0), (u(2)- etlp0)); %  - (((u(1)*u(2))-ni^2)/((taun_etl*(u(2)+ptetl)) + (taup_etl*(u(1)+ntetl))));
      - kradetl*((u(1)*u(2))-(ni^2)) - (((u(1)*u(2))-ni^2)/((taun_etl*(u(2)+ptetl)) + (taup_etl*(u(1)+ntetl))));   %- kradetl*((u(1)*u(2))-(ni^2)); % - klincon*min((u(1)- etln0), (u(2)- etlp0)); %- (((u(1)*u(2))-ni^2)/((taun_etl*(u(2)+ptetl)) + (taup_etl*(u(1)+ntetl))));
      0;
      (q/eppn)*(-u(1)+u(2)+u(3)-NI+ND);];%+ptetl-ntetl)];

  % n-type
elseif x >= tp + ti + tscr && x <= xmax
  
 f = [(mue_n*(u(1)*-DuDx(4)+kB*T*DuDx(1)));
     (muh_n*(u(2)*DuDx(4)+kB*T*DuDx(2)));      
     0;
     DuDx(4)];                                      

s = [ - kradetl*((u(1)*u(2))-(ni^2)) - (((u(1)*u(2))-ni^2)/((taun_etl*(u(2)+ptetl)) + (taup_etl*(u(1)+ntetl))));   %- kradetl*((u(1)*u(2))-(ni^2)); %- klincon*min((u(1)- etln0), (u(2)- etlp0)); %  - (((u(1)*u(2))-ni^2)/((taun_etl*(u(2)+ptetl)) + (taup_etl*(u(1)+ntetl))));
      - kradetl*((u(1)*u(2))-(ni^2)) - (((u(1)*u(2))-ni^2)/((taun_etl*(u(2)+ptetl)) + (taup_etl*(u(1)+ntetl))));   %- kradetl*((u(1)*u(2))-(ni^2)); % - klincon*min((u(1)- etln0), (u(2)- etlp0)); %- (((u(1)*u(2))-ni^2)/((taun_etl*(u(2)+ptetl)) + (taup_etl*(u(1)+ntetl))));
      0;
      (q/eppn)*(-u(1)+u(2)+ND+u(3)-NI);];%+ptetl-ntetl)];

end

end

%% Initial conditions
function u0 = pdex4ic(x)

%% Open circuit condition- symmetric model
if (OC ==1)
    
    if x >= xmax/2

        x = xmax - x;

    end
    
end

%% Initial conditions based on analytical solution p-i-n junction

if length(varargin) == 0 || length(varargin) >= 1 && max(max(max(varargin{1, 1}.sol))) == 0
    
    % p-type
    if x < (tp - wp)
    
       u0 = [htln0;
             htlp0;
              NI;
              0];  

    % p-type SCR    
    elseif  x >= (tp - wp) && x < tp

        u0 = [N0*exp((Efnside + EA + q*((((q*NA)/(2*eppi))*(x-tp+wp)^2)))/(kB*T));                            %ni*exp((Efnside - (-q*((((q*NA)/(2*eppp))*(x-tp+wp)^2))))/(kB*T));
              N0*exp(-(q*((((q*NA)/(2*eppi))*(x-tp+wp)^2)) + EA + Eg + Efpside)/(kB*T));
              NI;
              (((q*NA)/(2*eppi))*(x-tp+wp)^2)];

    % Intrinsic

    elseif x >= tp && x <= tp+ ti

        u0 =  [N0*exp((Efnside + EA + q*(((x - tp)*((1/ti)*(Vbi - ((q*NA*wp^2)/(2*eppi)) - ((q*ND*wn^2)/(2*eppi))))) + ((q*NA*wp^2)/(2*eppi))))/(kB*T));
                N0*exp(-(q*(((x - tp)*((1/ti)*(Vbi - ((q*NA*wp^2)/(2*eppi)) - ((q*ND*wn^2)/(2*eppi))))) + ((q*NA*wp^2)/(2*eppi))) + EA + Eg + Efpside)/(kB*T));
                NI;
                ((x - tp)*((1/ti)*(Vbi - ((q*NA*wp^2)/(2*eppi)) - ((q*ND*wn^2)/(2*eppi))))) + ((q*NA*wp^2)/(2*eppi)) ;];

    % n-type SCR    
    elseif  x > (tp+ti) && x <= (tp + ti + wn)

        u0 = [N0*exp((Efnside + EA + q*((((-(q*ND)/(2*eppi))*(x-ti-tp-wn)^2) + Vbi)))/(kB*T));
              N0*exp(-(q*((((-(q*ND)/(2*eppi))*(x-ti-tp-wn)^2) + Vbi)) + EA + Eg + Efpside)/(kB*T));
              NI;
              (((-(q*ND)/(2*eppi))*(x-tp - ti -wn)^2) + Vbi)]; 

    % n-type
    elseif x > (tp + ti + wn) && x <= xmax

         u0 = [etln0;
               etlp0;
               NI;
               Vbi];
    end      
    

%% Previous solution as initial conditions
elseif length(varargin) == 1 || length(varargin) >= 1 && max(max(max(varargin{1, 1}.sol))) ~= 0
    % insert previous solution and interpolate the x points
    u0 = [interp1(icx,icsol(end,:,1),x)
          interp1(icx,icsol(end,:,2),x)
          interp1(icx,icsol(end,:,3),x)
          interp1(icx,icsol(end,:,4),x)];

end

end

%% Boundary conditions
% Refer pdepe help for the precise meaning of p and q
% l and r refer to left and right.

function [pl,ql,pr,qr] = pdex4bc(xl,ul,xr,ur,t)

%% Current voltage scan, voltage sweep
if JV == 1
        
    Vapp = Vstart + ((Vend-Vstart)*t*(1/tmax));
    
end

%% Open circuit condition- symmetric model
if OC == 1
      
    pl = [0;
          0;
          0;
          -ul(4)];

    ql = [1; 
          1;
          1;
          0];

    pr = [0;
          0;
          0;
          -ur(4)];  

    qr = [1; 
          1;
          1;
          0];

else

%% Closed circuit condition
    
    % Zero current - rarely used but can be useful to switch off currents before switching
    % to OC in procedures.
    if BC == 0
        
        pl = [0;
            0;
            0;
            -ul(4)];
        
        ql = [1;
            1;
            1;
            0];
        
        pr = [0;
            0;
            0;
            -ur(4) + Vbi - Vapp;];
        
        qr = [1;
            1;
            1;
            0];
        
    % Fixed majority charge densities at the boundaries- contact in equilibrium with etl and htl
    % Blocking electrode- zero flux for minority carriers
    elseif BC == 1
        
        pl = [0;
            (ul(2)-htlp0);
            0;
            -ul(4);];
        
        ql = [1;
            0;
            1;
            0];
        
        pr = [(ur(1)-etln0);
            0;
            0;
            -ur(4)+Vbi-Vapp;];
        
        qr = [0;
            1;
            1;
            0];
        
    % Non- selective contacts - fixed charge densities for majority and minority carriers
    % equivalent to infinite surface recombination velocity for minority carriers
    elseif BC == 2
        
        pl = [ul(1) - htln0;
            ul(2) - htlp0;
            0;
            -ul(4);];
        
        ql = [0;
            0;
            1;
            0];
        
        pr = [ur(1) - etln0;
            ur(2) - etlp0;
            0;
            -ur(4)+Vbi-Vapp;];
        
        qr = [0;
            0;
            1;
            0];
    
    end
end

end

%--------------------------------------------------------------------------------------
%% RePack parameters in to structure 'params'
% Currently have to repack params since values change after unpacking
% Pack parameters in to structure 'params'
varcell = who('*')';                    % Store variables names in cell array
varcell = ['fieldnames', varcell];      % adhere to syntax for v2struct

params = v2struct(varcell);

%% Analysis, graphing-  required to obtain J and Voc

% Readout solutions to structure
solstruct.sol = sol;            
solstruct.x = x; 
solstruct.t = t;


% Remove unwanted data from the parameters structure
% Essential to prevent solution being stored in params structure and
% increasing the solution sizes massively
if length(varargin) == 0 || length(varargin) == 2 && max(max(max(varargin{1, 1}.sol))) == 0
    
    params = rmfield(params, 'sol');
    params = rmfield(params, 'params');
    params = rmfield(params, 'varargin');
    
else
    
    params = rmfield(params, 'sol');
    params = rmfield(params, 'icsol');
    params = rmfield(params, 'icx');  
    params = rmfield(params, 'params');
    params = rmfield(params, 'varargin');
    
end

% Store parameters structure
solstruct.params = params;

if Ana == 1
    
    [Voc, Vapp_arr, Jtotr] = pinAna(solstruct);
    
    if OC == 1
        
        solstruct.Voc = Voc;
        
    end
    
    if JV == 1
        
        solstruct.Vapp = Vapp_arr;
        
    end
    
    if calcJ ~= 0
        
        solstruct.Jtotr = Jtotr;
        
    end
    
end

params = rmfield(params, 'x');
params = rmfield(params, 't');
params = rmfield(params, 'options');

% Store parameters structure again!
solstruct.params = params;

end





